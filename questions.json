{
  "questions": [
    {
      "id": 1,
      "question": "Какая команда используется для компиляции Java-программы через командную строку?",
      "options": {
        "A": "run",
        "B": "execute",
        "C": "javac",
        "D": "compile",
        "E": "java"
      },
      "correct": "C"
    },
    {
      "id": 2,
      "question": "Как называется метод, с которого начинается выполнение программы в Java?",
      "options": {
        "A": "execute()",
        "B": "run()",
        "C": "main()",
        "D": "start()",
        "E": "init()"
      },
      "correct": "C"
    },
    {
      "id": 3,
      "question": "Какое расширение имеет файл, содержащий Java-исходный код?",
      "options": {
        "A": ".jav",
        "B": ".java",
        "C": ".class",
        "D": ".code",
        "E": ".src"
      },
      "correct": "B"
    },
    {
      "id": 4,
      "question": "Какой оператор используется для создания объекта в Java?",
      "options": {
        "A": "create",
        "B": "new",
        "C": "this",
        "D": "make",
        "E": "object"
      },
      "correct": "B"
    },
    {
      "id": 5,
      "question": "Как называется структура, которая позволяет выполнять действия в зависимости от логического условия?",
      "options": {
        "A": "условный оператор",
        "B": "цикл",
        "C": "массив",
        "D": "объект",
        "E": "функция"
      },
      "correct": "A"
    },
    {
      "id": 6,
      "question": "Какой из операторов используется для проверки равенства в Java?",
      "options": {
        "A": "=",
        "B": "==",
        "C": "!=",
        "D": "===",
        "E": "equals()"
      },
      "correct": "B"
    },
    {
      "id": 7,
      "question": "Как называется цикл, который выполняется, пока условие истинно?",
      "options": {
        "A": "while",
        "B": "for",
        "C": "switch",
        "D": "if",
        "E": "do"
      },
      "correct": "A"
    },
    {
      "id": 8,
      "question": "Какой модификатор указывает, что метод принадлежит классу, а не объекту?",
      "options": {
        "A": "private",
        "B": "final",
        "C": "static",
        "D": "abstract",
        "E": "public"
      },
      "correct": "C"
    },
    {
      "id": 9,
      "question": "Что используется для группировки переменных и методов, связанных логически в Java?",
      "options": {
        "A": "класс",
        "B": "интерфейс",
        "C": "объект",
        "D": "массив",
        "E": "пакет"
      },
      "correct": "A"
    },
    {
      "id": 10,
      "question": "Как называется базовый класс для всех классов в Java?",
      "options": {
        "A": "String",
        "B": "Object",
        "C": "System",
        "D": "Class",
        "E": "Base"
      },
      "correct": "B"
    },
    {
      "id": 11,
      "question": "Какой метод класса Object возвращает строковое представление объекта?",
      "options": {
        "A": "clone()",
        "B": "equals()",
        "C": "toString()",
        "D": "hashCode()",
        "E": "getString()"
      },
      "correct": "C"
    },
    {
      "id": 12,
      "question": "Как создаётся одномерный массив в Java?",
      "options": {
        "A": "int[] arr = new int[5];",
        "B": "int[] arr = {};",
        "C": "int arr = [5];",
        "D": "int arr(5);",
        "E": "int arr = array(5);"
      },
      "correct": "A"
    },
    {
      "id": 13,
      "question": "Какой метод используется для вычисления длины массива?",
      "options": {
        "A": "length",
        "B": "size",
        "C": "getLength",
        "D": "count",
        "E": "arraySize"
      },
      "correct": "A"
    },
    {
      "id": 14,
      "question": "Какая коллекция является реализацией динамического массива?",
      "options": {
        "A": "ArrayList",
        "B": "HashMap",
        "C": "TreeSet",
        "D": "PriorityQueue",
        "E": "Vector"
      },
      "correct": "A"
    },
    {
      "id": 15,
      "question": "Какой из следующих классов поддерживает обобщения (Generics)?",
      "options": {
        "A": "ArrayList",
        "B": "HashMap",
        "C": "Vector",
        "D": "LinkedList",
        "E": "Set"
      },
      "correct": "A"
    },
    {
      "id": 16,
      "question": "Что произойдет при попытке обратиться к элементу массива с индексом за пределами длины?",
      "options": {
        "A": "Ничего",
        "B": "Вернётся null",
        "C": "Бросится исключение ArrayIndexOutOfBoundsException",
        "D": "Будет создан новый элемент",
        "E": "Программа завершится без ошибки"
      },
      "correct": "C"
    },
    {
      "id": 17,
      "question": "Как называется блок кода, где обрабатываются исключения?",
      "options": {
        "A": "catch",
        "B": "throw",
        "C": "try-catch",
        "D": "finally",
        "E": "handle"
      },
      "correct": "C"
    },
    {
      "id": 18,
      "question": "Какой оператор используется для генерации исключения?",
      "options": {
        "A": "try",
        "B": "throw",
        "C": "catch",
        "D": "finally",
        "E": "raises"
      },
      "correct": "B"
    },
    {
      "id": 19,
      "question": "Какой метод класса Thread запускает поток?",
      "options": {
        "A": "execute()",
        "B": "start()",
        "C": "run()",
        "D": "init()",
        "E": "begin()"
      },
      "correct": "B"
    },
    {
      "id": 20,
      "question": "Что выполняет метод run() в потоке?",
      "options": {
        "A": "Останавливает поток",
        "B": "Определяет действия потока",
        "C": "Перезапускает поток",
        "D": "Закрывает поток",
        "E": "Инициализирует поток"
      },
      "correct": "B"
    },
    {
      "id": 21,
      "question": "Какой интерфейс используется для создания потока?",
      "options": {
        "A": "Callable",
        "B": "Runnable",
        "C": "Executor",
        "D": "Thread",
        "E": "ThreadInterface"
      },
      "correct": "B"
    },
    {
      "id": 22,
      "question": "Какая коллекция используется для хранения уникальных элементов?",
      "options": {
        "A": "List",
        "B": "ArrayList",
        "C": "HashSet",
        "D": "Stack",
        "E": "Array"
      },
      "correct": "C"
    },
    {
      "id": 23,
      "question": "Что обозначает метод close() в потоках?",
      "options": {
        "A": "Закрытие ресурса",
        "B": "Запуск потока",
        "C": "Очистка памяти",
        "D": "Остановка потока",
        "E": "Перезагрузка потока"
      },
      "correct": "A"
    },
    {
      "id": 24,
      "question": "Какой потоковый класс используется для записи данных в файл?",
      "options": {
        "A": "FileWriter",
        "B": "FileReader",
        "C": "BufferedReader",
        "D": "PrintStream",
        "E": "DataWriter"
      },
      "correct": "A"
    },
    {
      "id": 25,
      "question": "Какой метод используется для чтения строки из потока?",
      "options": {
        "A": "readLine()",
        "B": "read()",
        "C": "next()",
        "D": "scan()",
        "E": "getLine()"
      },
      "correct": "A"
    },
    {
      "id": 26,
      "question": "Какой класс используется для управления группой потоков?",
      "options": {
        "A": "ThreadGroup",
        "B": "ExecutorService",
        "C": "Semaphore",
        "D": "Pool",
        "E": "ThreadPool"
      },
      "correct": "B"
    },
    {
      "id": 27,
      "question": "Что делает метод join() у потока?",
      "options": {
        "A": "Ожидает завершения выполнения потока",
        "B": "Приостанавливает поток",
        "C": "Перезапускает поток",
        "D": "Уничтожает поток",
        "E": "Объединяет потоки"
      },
      "correct": "A"
    },
    {
      "id": 28,
      "question": "Какая коллекция хранит элементы в порядке добавления?",
      "options": {
        "A": "LinkedList",
        "B": "HashSet",
        "C": "TreeMap",
        "D": "PriorityQueue",
        "E": "OrderedList"
      },
      "correct": "A"
    },
    {
      "id": 29,
      "question": "Какой класс используется для обработки объектов в стиле ключ-значение?",
      "options": {
        "A": "List",
        "B": "ArrayList",
        "C": "HashMap",
        "D": "Stack",
        "E": "Dictionary"
      },
      "correct": "C"
    },
    {
      "id": 30,
      "question": "Какой оператор используется для проверки экземпляра объекта?",
      "options": {
        "A": "instanceof",
        "B": "instance",
        "C": "is",
        "D": "equals",
        "E": "typeof"
      },
      "correct": "A"
    },
    {
      "id": 31,
      "question": "Как называется метод, который завершается всегда?",
      "options": {
        "A": "throw()",
        "B": "try()",
        "C": "finally()",
        "D": "finally",
        "E": "end()"
      },
      "correct": "D"
    },
    {
      "id": 32,
      "question": "Какой класс используется для сериализации объектов?",
      "options": {
        "A": "String",
        "B": "ObjectOutputStream",
        "C": "FileReader",
        "D": "DataOutput",
        "E": "Serializer"
      },
      "correct": "B"
    },
    {
      "id": 33,
      "question": "Что используется для синхронизации потоков?",
      "options": {
        "A": "Lock",
        "B": "synchronized",
        "C": "static",
        "D": "run",
        "E": "mutex"
      },
      "correct": "B"
    },
    {
      "id": 34,
      "question": "Какая структура данных используется для хранения данных в виде стека?",
      "options": {
        "A": "Stack",
        "B": "Queue",
        "C": "Deque",
        "D": "Array",
        "E": "List"
      },
      "correct": "A"
    },
    {
      "id": 35,
      "question": "Какой модификатор доступа запрещает наследование класса?",
      "options": {
        "A": "static",
        "B": "final",
        "C": "private",
        "D": "protected",
        "E": "sealed"
      },
      "correct": "B"
    },
    {
      "id": 36,
      "question": "Какой метод можно переопределить для выполнения собственной логики сравнения объектов?",
      "options": {
        "A": "equals()",
        "B": "toString()",
        "C": "hashCode()",
        "D": "clone()",
        "E": "compare()"
      },
      "correct": "A"
    },
    {
      "id": 37,
      "question": "Какой из следующих классов реализует интерфейс Map?",
      "options": {
        "A": "ArrayList",
        "B": "HashMap",
        "C": "Vector",
        "D": "TreeSet",
        "E": "Collection"
      },
      "correct": "B"
    },
    {
      "id": 38,
      "question": "Какой поток в Java завершает выполнение последним?",
      "options": {
        "A": "Daemon",
        "B": "Executor",
        "C": "Main",
        "D": "User",
        "E": "Background"
      },
      "correct": "A"
    },
    {
      "id": 39,
      "question": "Какой метод позволяет задать имя потока?",
      "options": {
        "A": "setName()",
        "B": "nameThread()",
        "C": "setThreadName()",
        "D": "setID()",
        "E": "assignName()"
      },
      "correct": "A"
    },
    {
      "id": 40,
      "question": "Что является точкой входа для многопоточности в Java?",
      "options": {
        "A": "Thread",
        "B": "Executor",
        "C": "Runnable",
        "D": "Semaphore",
        "E": "ThreadEntry"
      },
      "correct": "C"
    },
    {
      "id": 41,
      "question": "Что из ниже перечисленного является основным модулем Spring Framework?",
      "options": {
        "A": "Hibernate",
        "B": "Core Container",
        "C": "Maven",
        "D": "JPA",
        "E": "Kubernetes"
      },
      "correct": "B"
    },
    {
      "id": 42,
      "question": "Какой модуль отвечает за управление объектами в Spring?",
      "options": {
        "A": "Aspect-Oriented Programming",
        "B": "Core Container",
        "C": "Web",
        "D": "Data Access",
        "E": "Security"
      },
      "correct": "B"
    },
    {
      "id": 43,
      "question": "Для чего используется модуль Spring MVC?",
      "options": {
        "A": "Управление безопасностью приложения",
        "B": "Обработка запросов и создание веб-интерфейсов",
        "C": "Работа с базами данных",
        "D": "Управление транзакциями",
        "E": "Интеграция с другими фреймворками"
      },
      "correct": "B"
    },
    {
      "id": 44,
      "question": "Какой модуль Spring поддерживает внедрение зависимостей (Dependency Injection)?",
      "options": {
        "A": "Test",
        "B": "Security",
        "C": "Core Container",
        "D": "Expression Language",
        "E": "Context"
      },
      "correct": "C"
    },
    {
      "id": 45,
      "question": "Чем Spring Boot отличается от классического Spring Framework?",
      "options": {
        "A": "Отсутствием встроенных серверов",
        "B": "Поддержкой автоматической конфигурации",
        "C": "Наличием только модульной структуры",
        "D": "Невозможностью создания REST API",
        "E": "Отсутствием поддержки аннотаций"
      },
      "correct": "B"
    },
    {
      "id": 46,
      "question": "Какой встроенный сервер чаще всего используется с Spring Boot?",
      "options": {
        "A": "Apache Tomcat",
        "B": "Jetty",
        "C": "Undertow",
        "D": "GlassFish",
        "E": "WildFly"
      },
      "correct": "A"
    },
    {
      "id": 47,
      "question": "Какая аннотация используется для создания REST-контроллера в Spring Boot?",
      "options": {
        "A": "@Controller",
        "B": "@Service",
        "C": "@Repository",
        "D": "@RestController",
        "E": "@Component"
      },
      "correct": "D"
    },
    {
      "id": 48,
      "question": "Какой файл используется для настройки Spring Boot приложения?",
      "options": {
        "A": "application.json",
        "B": "bootstrap.xml",
        "C": "application.properties",
        "D": "settings.yml",
        "E": "spring-config.yml"
      },
      "correct": "C"
    },
    {
      "id": 49,
      "question": "Что такое Spring Data JPA?",
      "options": {
        "A": "Инструмент для тестирования",
        "B": "Модуль для интеграции с REST API",
        "C": "Абстракция для работы с базами данных",
        "D": "Утилита для работы с XML",
        "E": "Инструмент управления сессиями"
      },
      "correct": "C"
    },
    {
      "id": 50,
      "question": "Какая аннотация определяет сущность в JPA?",
      "options": {
        "A": "@Table",
        "B": "@Column",
        "C": "@Entity",
        "D": "@Id",
        "E": "@Data"
      },
      "correct": "C"
    },
    {
      "id": 51,
      "question": "Какой метод из репозитория Spring Data возвращает объект по его идентификатору?",
      "options": {
        "A": "findAll()",
        "B": "findById()",
        "C": "getById()",
        "D": "deleteById()",
        "E": "save()"
      },
      "correct": "B"
    },
    {
      "id": 52,
      "question": "Какая аннотация используется для задания первичного ключа в сущности JPA?",
      "options": {
        "A": "@PrimaryKey",
        "B": "@Id",
        "C": "@Key",
        "D": "@Column",
        "E": "@Generated"
      },
      "correct": "B"
    },
    {
      "id": 53,
      "question": "Какой класс используется для обработки ошибок в Spring MVC?",
      "options": {
        "A": "@ErrorHandler",
        "B": "@ControllerAdvice",
        "C": "@RestError",
        "D": "@ExceptionMapper",
        "E": "@ErrorMapping"
      },
      "correct": "B"
    },
    {
      "id": 54,
      "question": "Что делает аннотация @ExceptionHandler?",
      "options": {
        "A": "Логирует ошибки",
        "B": "Определяет класс для обработки исключений",
        "C": "Указывает метод, который обрабатывает конкретное исключение",
        "D": "Подключает обработчики ошибок к REST API",
        "E": "Вызывает исключение"
      },
      "correct": "C"
    },
    {
      "id": 55,
      "question": "Какой HTTP статус-код возвращается при выбросе исключения ResponseStatusException?",
      "options": {
        "A": "404",
        "B": "500",
        "C": "Определяется в параметрах исключения",
        "D": "400",
        "E": "200"
      },
      "correct": "C"
    },
    {
      "id": 56,
      "question": "Что из ниже перечисленного является лучшей практикой обработки ошибок в Spring Boot?",
      "options": {
        "A": "Игнорирование всех ошибок",
        "B": "Использование глобальных обработчиков исключений",
        "C": "Логирование ошибок вручную",
        "D": "Перехват всех исключений в контроллерах",
        "E": "Использование библиотеки Hibernate"
      },
      "correct": "B"
    },
    {
      "id": 57,
      "question": "Какой интерфейс используется для создания пользовательского репозитория?",
      "options": {
        "A": "JpaRepository",
        "B": "CrudRepository",
        "C": "BaseRepository",
        "D": "DataRepository",
        "E": "Repository"
      },
      "correct": "A"
    },
    {
      "id": 58,
      "question": "Какой HTTP метод используется для создания ресурса в REST API?",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE",
        "E": "OPTIONS"
      },
      "correct": "B"
    },
    {
      "id": 59,
      "question": "Что произойдет, если не обрабатывать исключения в Spring Boot?",
      "options": {
        "A": "Приложение завершится с ошибкой",
        "B": "Клиент получит HTTP статус-код 500",
        "C": "Клиент получит ответ с пустым телом",
        "D": "Все исключения будут скрыты",
        "E": "Приложение продолжит работу без изменений"
      },
      "correct": "B"
    },
    {
      "id": 60,
      "question": "Какой аннотацией можно заменить @RequestMapping(method = RequestMetho\nD)GET)?",
      "options": {
        "A": "@GetMapping",
        "B": "@RequestGet",
        "C": "@Mapping",
        "D": "@Controller",
        "E": "@Route"
      },
      "correct": "A"
    },
    {
      "id": 61,
      "question": "Какой паттерн проектирования пошагово конструирует сложный объект?",
      "options": {
        "A": "Строитель",
        "B": "Абстрактная фабрика",
        "C": "Шаблонный метод",
        "D": "Фабричный метод",
        "E": "Мост"
      },
      "correct": "A"
    },
    {
      "id": 62,
      "question": "Какой паттерн проектирования определяет каркас алгоритма в методе суперкласса?",
      "options": {
        "A": "Абстрактная фабрика",
        "B": "Шаблонный метод",
        "C": "Фабричный метод",
        "D": "Строитель",
        "E": "Мост"
      },
      "correct": "E"
    },
    {
      "id": 63,
      "question": "Какой паттерн проектирования позволяет создавать семейства связанных объектов?",
      "options": {
        "A": "Строитель",
        "B": "Абстрактная фабрика",
        "C": "Шаблонный метод",
        "D": "Фабричный метод",
        "E": "Мост"
      },
      "correct": "B"
    },
    {
      "id": 64,
      "question": "Какой паттерн проектирования создаёт объекты через общий интерфейс?",
      "options": {
        "A": "Абстрактная фабрика",
        "B": "Шаблонный метод",
        "C": "Строитель",
        "D": "Фабричный метод",
        "E": "Мост"
      },
      "correct": "D"
    },
    {
      "id": 65,
      "question": "Какой паттерн проектирования разделяет абстракцию и реализацию?",
      "options": {
        "A": "Абстрактная фабрика",
        "B": "Шаблонный метод",
        "C": "Фабричный метод",
        "D": "Строитель",
        "E": "Мост"
      },
      "correct": "C"
    },
    {
      "id": 66,
      "question": "Какое описание подходит для паттерна Адаптер?",
      "options": {
        "A": "Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом",
        "B": "Определяет семейство алгоритмов и позволяет переключаться между ними",
        "C": "Гарантирует существование только одного экземпляра класса",
        "D": "Создаёт новые объекты путём клонирования существующего объекта-прототипа",
        "E": "Оптимизирует использование памяти, разделяя общее состояние"
      },
      "correct": "A"
    },
    {
      "id": 67,
      "question": "Какое описание подходит для паттерна Прототип?",
      "options": {
        "A": "Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом",
        "B": "Определяет семейство алгоритмов и позволяет переключаться между ними",
        "C": "Создаёт новые объекты путём клонирования существующего объекта-прототипа",
        "D": "Гарантирует существование только одного экземпляра класса",
        "E": "Оптимизирует использование памяти, разделяя общее состояние"
      },
      "correct": "C"
    },
    {
      "id": 68,
      "question": "Какое описание подходит для паттерна Стратегия?",
      "options": {
        "A": "Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом",
        "B": "Гарантирует существование только одного экземпляра класса",
        "C": "Создаёт новые объекты путём клонирования существующего объекта-прототипа",
        "D": "Определяет семейство алгоритмов и позволяет переключаться между ними",
        "E": "Оптимизирует использование памяти, разделяя общее состояние"
      },
      "correct": "D"
    },
    {
      "id": 69,
      "question": "Какое описание подходит для паттерна Одиночка?",
      "options": {
        "A": "Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом",
        "B": "Гарантирует существование только одного экземпляра класса",
        "C": "Создаёт новые объекты путём клонирования существующего объекта-прототипа",
        "D": "Определяет семейство алгоритмов и позволяет переключаться между ними",
        "E": "Оптимизирует использование памяти, разделяя общее состояние"
      },
      "correct": "B"
    },
    {
      "id": 70,
      "question": "Какое описание подходит для паттерна Легковес?",
      "options": {
        "A": "Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом",
        "B": "Определяет семейство алгоритмов и позволяет переключаться между ними",
        "C": "Гарантирует существование только одного экземпляра класса",
        "D": "Создаёт новые объекты путём клонирования существующего объекта-прототипа",
        "E": "Оптимизирует использование памяти, разделяя общее состояние"
      },
      "correct": "E"
    },
    {
      "id": 71,
      "question": "Какой паттерн проектирования необходимо использовать когда нужно переключаться между различными алгоритмами?",
      "options": {
        "A": "Стратегия",
        "B": "Одиночка",
        "C": "Легковес",
        "D": "Прототип",
        "E": "Адаптер"
      },
      "correct": "D"
    },
    {
      "id": 72,
      "question": "Какой паттерн проектирования необходимо использовать когда нужно использовать существующий класс с несовместимым интерфейсом?",
      "options": {
        "A": "Стратегия",
        "B": "Одиночка",
        "C": "Легковес",
        "D": "Прототип",
        "E": "Адаптер"
      },
      "correct": "B"
    },
    {
      "id": 73,
      "question": "Какой паттерн проектирования необходимо использовать когда требуется единственный экземпляр класса?",
      "options": {
        "A": "Одиночка",
        "B": "Стратегия",
        "C": "Легковес",
        "D": "Прототип",
        "E": "Адаптер"
      },
      "correct": "A"
    },
    {
      "id": 74,
      "question": "Какой паттерн проектирования необходимо использовать когда создание объекта сложно, а требуется копирование?",
      "options": {
        "A": "Стратегия",
        "B": "Одиночка",
        "C": "Прототип",
        "D": "Легковес",
        "E": "Адаптер"
      },
      "correct": "C"
    },
    {
      "id": 75,
      "question": "Какой паттерн проектирования необходимо использовать когда приложение обрабатывает много мелких объектов?",
      "options": {
        "A": "Стратегия",
        "B": "Одиночка",
        "C": "Легковес",
        "D": "Прототип",
        "E": "Адаптер"
      },
      "correct": "E"
    },
    {
      "id": 76,
      "question": "В каком случае используют паттерн Абстрактная фабрика?",
      "options": {
        "A": "Когда нужно создать семейство связанных объектов, совместимых между собой",
        "B": "Когда алгоритм должен быть гибким и изменяемым",
        "C": "Когда класс не знает, объекты какого типа создавать",
        "D": "Когда объект имеет много параметров",
        "E": "Когда нужно разделить систему на два уровня"
      },
      "correct": "A"
    },
    {
      "id": 77,
      "question": "В каком случае используют паттерн Фабричный метод?",
      "options": {
        "A": "Когда нужно создать семейство связанных объектов",
        "B": "Когда алгоритм должен быть гибким и изменяемым",
        "C": "Когда класс не знает, объекты какого типа создавать",
        "D": "Когда объект имеет много параметров",
        "E": "Когда нужно разделить систему на два уровня"
      },
      "correct": "C"
    },
    {
      "id": 78,
      "question": "В каком случае используют паттерн Строитель?",
      "options": {
        "A": "Когда нужно создать семейство связанных объектов",
        "B": "Когда алгоритм должен быть гибким и изменяемым",
        "C": "Когда класс не знает, объекты какого типа создавать",
        "D": "Когда объект имеет много параметров или может быть представлен в разных вариациях",
        "E": "Когда нужно разделить систему на два уровня"
      },
      "correct": "D"
    },
    {
      "id": 79,
      "question": "В каком случае используют паттерн Шаблонный метод?",
      "options": {
        "A": "Когда нужно создать семейство связанных объектов",
        "B": "Когда алгоритм должен быть гибким и изменяемым, но его структура неизменна",
        "C": "Когда класс не знает, объекты какого типа создавать",
        "D": "Когда объект имеет много параметров",
        "E": "Когда нужно разделить систему на два уровня"
      },
      "correct": "B"
    },
    {
      "id": 80,
      "question": "В каком случае используют паттерн Мост?",
      "options": {
        "A": "Когда нужно создать семейство связанных объектов",
        "B": "Когда алгоритм должен быть гибким и изменяем",
        "C": "Когда класс не знает, объекты какого типа ему нужно создавать.",
        "D": "Когда объект имеет много параметров или может быть представлен в разных вариациях.",
        "E": "Когда нужно разделить сложную систему на два уровня, которые можно изменять независимо."
      },
      "correct": "E"
    },
    {
      "id": 81,
      "question": "Для чего используется аннотация @Controller в Spring MVC?",
      "options": {
        "A": "Для подключения базы данных",
        "B": "Для создания модели данных",
        "C": "Для определения контроллера",
        "D": "Для настройки маршрутизации",
        "E": "Для упрощения работы с REST API"
      },
      "correct": "C"
    },
    {
      "id": 82,
      "question": "Что такое Model в Spring MVC?",
      "options": {
        "A": "Контроллер для обработки запросов",
        "B": "Репозиторий для работы с базой данных",
        "C": "Объект для передачи данных между контроллером и представлением",
        "D": "Сервис для бизнес-логики",
        "E": "Маршрут для конфигурации"
      },
      "correct": "C"
    },
    {
      "id": 83,
      "question": "Какой объект используется для отправки данных в представление?",
      "options": {
        "A": "Model",
        "B": "View",
        "C": "Request",
        "D": "Response",
        "E": "Controller"
      },
      "correct": "A"
    },
    {
      "id": 84,
      "question": "Для чего используется аннотация @RequestMapping?",
      "options": {
        "A": "Для указания имени контроллера",
        "B": "Для сопоставления запросов с методами контроллера",
        "C": "Для настройки базы данных",
        "D": "Для создания модели",
        "E": "Для указания пути к статическим ресурсам"
      },
      "correct": "B"
    },
    {
      "id": 85,
      "question": "Какой метод HTTP обычно используется для получения данных?",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE",
        "E": "PATCH"
      },
      "correct": "A"
    },
    {
      "id": 86,
      "question": "Как в Spring MVC можно получить параметры из URL?",
      "options": {
        "A": "С помощью объекта Response",
        "B": "С помощью аннотации @RequestParam",
        "C": "С помощью Model",
        "D": "С помощью @Controller",
        "E": "С помощью @GetMapping"
      },
      "correct": "B"
    },
    {
      "id": 87,
      "question": "Для чего используется аннотация @RestController?",
      "options": {
        "A": "Для управления базой данных",
        "B": "Для упрощения работы с REST API",
        "C": "Для создания представления",
        "D": "Для настройки маршрутов",
        "E": "Для создания моделей данных"
      },
      "correct": "B"
    },
    {
      "id": 88,
      "question": "Какой объект отвечает за отображение данных в браузере?",
      "options": {
        "A": "Model",
        "B": "View",
        "C": "Response",
        "D": "Request",
        "E": "Template"
      },
      "correct": "B"
    },
    {
      "id": 89,
      "question": "Какой стандартный порт используется для запуска Spring Boot приложения?",
      "options": {
        "A": "3000",
        "B": "8080",
        "C": "5000",
        "D": "3306",
        "E": "7000"
      },
      "correct": "B"
    },
    {
      "id": 90,
      "question": "Какая аннотация используется для маппинга POST-запросов?",
      "options": {
        "A": "@GetMapping",
        "B": "@PostMapping",
        "C": "@RequestParam",
        "D": "@RestController",
        "E": "@RequestMapping"
      },
      "correct": "B"
    },
    {
      "id": 91,
      "question": "Для чего используется JDBC в Java?",
      "options": {
        "A": "Для взаимодействия с реляционными базами данных",
        "B": "Для работы с REST API",
        "C": "Для настройки веб-контроллеров",
        "D": "Для компиляции SQL-запросов",
        "E": "Для тестирования SQL-команд"
      },
      "correct": "A"
    },
    {
      "id": 92,
      "question": "Что такое SQL?",
      "options": {
        "A": "Язык программирования для веб-приложений",
        "B": "Язык для управления данными в базе данных",
        "C": "Протокол передачи данных",
        "D": "Тип базы данных",
        "E": "Система управления версиями"
      },
      "correct": "B"
    },
    {
      "id": 93,
      "question": "Какой инструмент используется для тестирования запросов к базе данных?",
      "options": {
        "A": "Spring MVC",
        "B": "SQL консоль",
        "C": "IntelliJ IDEA",
        "D": "REST API",
        "E": "Postman"
      },
      "correct": "B"
    },
    {
      "id": 94,
      "question": "Какой запрос используется для получения данных из таблицы?",
      "options": {
        "A": "INSERT",
        "B": "SELECT",
        "C": "UPDATE",
        "D": "DELETE",
        "E": "CREATE"
      },
      "correct": "B"
    },
    {
      "id": 95,
      "question": "Какая библиотека помогает интегрировать Spring с базами данных?",
      "options": {
        "A": "Spring MVC",
        "B": "Spring Data JPA",
        "C": "Spring Security",
        "D": "Hibernate Tools",
        "E": "Liquibase"
      },
      "correct": "B"
    },
    {
      "id": 96,
      "question": "Для чего используется аннотация @Entity?",
      "options": {
        "A": "Для создания таблицы в базе данных",
        "B": "Для определения класса как сущности базы данных",
        "C": "Для настройки контроллера",
        "D": "Для управления транзакциями",
        "E": "Для настройки соединения"
      },
      "correct": "B"
    },
    {
      "id": 97,
      "question": "Какой запрос используется для обновления данных в таблице?",
      "options": {
        "A": "SELECT",
        "B": "DELETE",
        "C": "UPDATE",
        "D": "CREATE",
        "E": "ALTER"
      },
      "correct": "C"
    },
    {
      "id": 98,
      "question": "Для чего используется аннотация @Repository?",
      "options": {
        "A": "Для создания контроллеров",
        "B": "Для определения класса как репозитория",
        "C": "Для работы с моделью",
        "D": "Для настройки базы данных",
        "E": "Для управления транзакциями"
      },
      "correct": "B"
    },
    {
      "id": 99,
      "question": "Какая команда используется для удаления данных из таблицы?",
      "options": {
        "A": "SELECT",
        "B": "INSERT",
        "C": "UPDATE",
        "D": "DELETE",
        "E": "DROP"
      },
      "correct": "D"
    },
    {
      "id": 100,
      "question": "Что такое первичный ключ в базе данных?",
      "options": {
        "A": "Поле для хранения паролей",
        "B": "Уникальное поле, идентифицирующее запись",
        "C": "Поле для внешних связей",
        "D": "Поле для хранения индексов",
        "E": "Поле для хранения временных меток"
      },
      "correct": "B"
    },
    {
      "id": 101,
      "question": "Что такое CRUD?",
      "options": {
        "A": "Создание, чтение, обновление, удаление",
        "B": "Работа с REST API",
        "C": "Тестирование базы данных",
        "D": "Визуализация данных",
        "E": "Управление связями между таблицами"
      },
      "correct": "A"
    },
    {
      "id": 102,
      "question": "Для чего используется H2 Database в Spring Boot?",
      "options": {
        "A": "Для работы с встроенной базой данных",
        "B": "Для создания контроллеров",
        "C": "Для настройки REST API",
        "D": "Для отображения данных",
        "E": "Для управления транзакциями"
      },
      "correct": "A"
    },
    {
      "id": 103,
      "question": "Какой метод используется для чтения данных в JPA?",
      "options": {
        "A": "findById",
        "B": "save",
        "C": "deleteById",
        "D": "create",
        "E": "findAll"
      },
      "correct": "A"
    },
    {
      "id": 104,
      "question": "Какую библиотеку можно использовать для тестирования CRUD-операций?",
      "options": {
        "A": "JUnit",
        "B": "Spring MVC",
        "C": "Hibernate",
        "D": "IntelliJ IDEA",
        "E": "Mockito"
      },
      "correct": "A"
    },
    {
      "id": 105,
      "question": "Для чего используется аннотация @Transactional?",
      "options": {
        "A": "Для определения таблицы",
        "B": "Для управления транзакциями",
        "C": "Для настройки контроллера",
        "D": "Для управления данными",
        "E": "Для настройки логирования"
      },
      "correct": "B"
    },
    {
      "id": 106,
      "question": "Что возвращает метод save() в Spring Data JPA?",
      "options": {
        "A": "Сохраненный объект",
        "B": "Идентификатор объекта",
        "C": "Ошибку сохранения",
        "D": "Ничего",
        "E": "Объект типа void"
      },
      "correct": "A"
    },
    {
      "id": 107,
      "question": "Какая команда используется для создания новой записи в таблице?",
      "options": {
        "A": "INSERT",
        "B": "SELECT",
        "C": "DELETE",
        "D": "UPDATE",
        "E": "CREATE"
      },
      "correct": "A"
    },
    {
      "id": 108,
      "question": "Какой инструмент используется для мониторинга SQL-запросов?",
      "options": {
        "A": "Hibernate SQL Logging",
        "B": "Spring Boot",
        "C": "IntelliJ IDEA",
        "D": "JUnit",
        "E": "DataGrip"
      },
      "correct": "A"
    },
    {
      "id": 109,
      "question": "Для чего используется аннотация @Id?",
      "options": {
        "A": "Для указания первичного ключа сущности",
        "B": "Для создания таблицы",
        "C": "Для маппинга данных",
        "D": "Для настройки контроллера",
        "E": "Для указания внешнего ключа"
      },
      "correct": "A"
    },
    {
      "id": 110,
      "question": "Какая аннотация используется для маппинга таблицы в классе?",
      "options": {
        "A": "@Table",
        "B": "@Column",
        "C": "@Entity",
        "D": "@Data",
        "E": "@Id"
      },
      "correct": "A"
    },
    {
      "id": 111,
      "question": "Для чего используется аннотация @PathVariable в Spring MVC?",
      "options": {
        "A": "Для передачи данных в модель",
        "B": "Для настройки конфигурации приложения",
        "C": "Для получения данных из URL",
        "D": "Для указания на обработку ошибок",
        "E": "Для связи с базой данных"
      },
      "correct": "C"
    },
    {
      "id": 112,
      "question": "Какая аннотация используется для указания метода как обработчика GET-запросов?",
      "options": {
        "A": "@PostMapping",
        "B": "@GetMapping",
        "C": "@RequestParam",
        "D": "@RestController",
        "E": "@RequestMapping"
      },
      "correct": "B"
    },
    {
      "id": 113,
      "question": "Что делает аннотация @Service в Spring?",
      "options": {
        "A": "Определяет репозиторий базы данных",
        "B": "Определяет компонент, содержащий бизнес-логику",
        "C": "Определяет контроллер",
        "D": "Настраивает связь с базой данных",
        "E": "Настраивает сериализацию"
      },
      "correct": "B"
    },
    {
      "id": 114,
      "question": "Какое значение имеет параметр \"name\" в аннотации @RequestParam?",
      "options": {
        "A": "Указывает, что параметр является обязательным",
        "B": "Связывает параметр с телом запроса",
        "C": "Определяет имя параметра из URL или тела запроса",
        "D": "Указывает на возврат HTML",
        "E": "Задает тип параметра"
      },
      "correct": "C"
    },
    {
      "id": 115,
      "question": "Для чего используется интерфейс JpaRepository?",
      "options": {
        "A": "Для создания SQL-запросов вручную",
        "B": "Для работы с сущностями базы данных с минимальным количеством кода",
        "C": "Для настройки базовых параметров базы данных",
        "D": "Для тестирования приложения",
        "E": "Для выполнения миграций"
      },
      "correct": "B"
    },
    {
      "id": 116,
      "question": "Какую ошибку выбросит Spring, если отсутствует обязательный параметр @RequestParam?",
      "options": {
        "A": "MissingServletRequestParameterException",
        "B": "NullPointerException",
        "C": "SQLException",
        "D": "MissingEntityException",
        "E": "IllegalArgumentException"
      },
      "correct": "A"
    },
    {
      "id": 117,
      "question": "Что такое DataSource в контексте Spring?",
      "options": {
        "A": "Это класс для выполнения SQL-запросов",
        "B": "Это объект, представляющий соединение с базой данных",
        "C": "Это модель данных для фронтенда",
        "D": "Это контроллер для обработки запросов",
        "E": "Это фабрика запросов"
      },
      "correct": "B"
    },
    {
      "id": 118,
      "question": "Какой метод используется для удаления сущности по ID в Spring Data JPA?",
      "options": {
        "A": "deleteAll()",
        "B": "deleteById()",
        "C": "removeEntity()",
        "D": "removeById()",
        "E": "findAndRemove()"
      },
      "correct": "B"
    },
    {
      "id": 119,
      "question": "Какая аннотация используется для маппинга столбцов таблицы на поля класса?",
      "options": {
        "A": "@Entity",
        "B": "@Table",
        "C": "@Column",
        "D": "@PrimaryKey",
        "E": "@JoinColumn"
      },
      "correct": "C"
    },
    {
      "id": 120,
      "question": "Какую аннотацию можно использовать для управления версионностью сущностей в Spring?",
      "options": {
        "A": "@Table",
        "B": "@Id",
        "C": "@Version",
        "D": "@GeneratedValue",
        "E": "@Column"
      },
      "correct": "C"
    },
    {
      "id": 121,
      "question": "Что такое логирование?",
      "options": {
        "A": "Метод для оптимизации производительности кода",
        "B": "Процесс установки драйверов",
        "C": "Инструмент для тестирования кода",
        "D": "Запись событий, происходящих в приложении, для их анализа",
        "E": "Способ шифрования данных"
      },
      "correct": "D"
    },
    {
      "id": 122,
      "question": "Какая основная цель логирования?",
      "options": {
        "A": "Увеличение скорости работы приложения",
        "B": "Обеспечение мониторинга и диагностики приложений",
        "C": "Создание резервных копий данных",
        "D": "Снижение энергопотребления сервера",
        "E": "Улучшение пользовательского интерфейса"
      },
      "correct": "B"
    },
    {
      "id": 123,
      "question": "Какой пакет используется для встроенного логирования в Java?",
      "options": {
        "A": "java.sql",
        "B": "java.util.logging",
        "C": "java.io.logging",
        "D": "java.logging.framework",
        "E": "java.log"
      },
      "correct": "B"
    },
    {
      "id": 124,
      "question": "Какой метод из Logger используется для записи информационного сообщения?",
      "options": {
        "A": "logInfo()",
        "B": "info()",
        "C": "log(Level.INFO, message)",
        "D": "writeLog()",
        "E": "logMessage()"
      },
      "correct": "B"
    },
    {
      "id": 125,
      "question": "Какой формат конфигурации не поддерживается log4j?",
      "options": {
        "A": "XML",
        "B": "JSON",
        "C": "CSV",
        "D": "YAML",
        "E": "INI"
      },
      "correct": "C"
    },
    {
      "id": 126,
      "question": "Что обозначает <root> в конфигурации log4j?",
      "options": {
        "A": "Имя пакета для логирования",
        "B": "Главный логгер приложения",
        "C": "Уровень детализации логирования",
        "D": "Библиотеку для записи логов",
        "E": "Корневой каталог для хранения логов"
      },
      "correct": "B"
    },
    {
      "id": 127,
      "question": "Какова основная цель SLF4J?",
      "options": {
        "A": "Предоставление встроенной поддержки логирования для JDK",
        "B": "Абстракция для упрощения работы с различными библиотеками логирования",
        "C": "Ускорение работы с потоками",
        "D": "Поддержка асинхронного логирования",
        "E": "Управление зависимостями в проекте"
      },
      "correct": "B"
    },
    {
      "id": 128,
      "question": "Какое из утверждений о SLF4J является правильным?",
      "options": {
        "A": "Это интерфейс для различных фреймворков логирования",
        "B": "Это расширение log4j для многопоточности",
        "C": "Это инструмент для управления зависимостями",
        "D": "Это встроенная библиотека в Java",
        "E": "Это библиотека для работы с базами данных"
      },
      "correct": "A"
    },
    {
      "id": 129,
      "question": "Какую библиотеку нужно подключить для интеграции SLF4J с log4j?",
      "options": {
        "A": "slf4j-log4j12",
        "B": "log4j-slf4j-connector",
        "C": "log4j2-slf4j-bridge",
        "D": "slf4j-logger",
        "E": "slf4j-core"
      },
      "correct": "A"
    },
    {
      "id": 130,
      "question": "Что произойдет, если не подключить реализацию SLF4J?",
      "options": {
        "A": "Логи будут записываться в консоль по умолчанию",
        "B": "При попытке логирования появится ошибка \"No SLF4J binding found\"",
        "C": "Логирование будет работать, но без форматирования",
        "D": "SLF4J автоматически найдет библиотеку для работы",
        "E": "Логирование будет отключено"
      },
      "correct": "B"
    },
    {
      "id": 131,
      "question": "Как называется механизм log4j, который позволяет фильтровать логи?",
      "options": {
        "A": "Log Filters",
        "B": "Appender Filters",
        "C": "Logger Filters",
        "D": "Filter Manager",
        "E": "Log4j Filters"
      },
      "correct": "B"
    },
    {
      "id": 132,
      "question": "Какой тип Appender подходит для записи логов в базу данных?",
      "options": {
        "A": "ConsoleAppender",
        "B": "FileAppender",
        "C": "JDBCAppender",
        "D": "RollingFileAppender",
        "E": "DatabaseAppender"
      },
      "correct": "C"
    },
    {
      "id": 133,
      "question": "Какой из подходов используется для безопасного логирования в многопоточных приложениях?",
      "options": {
        "A": "Использование обычного FileAppender",
        "B": "Использование асинхронного логгера",
        "C": "Отключение логирования в потоках",
        "D": "Создание отдельного файла для каждого потока",
        "E": "Использование синхронизированных логгеров"
      },
      "correct": "B"
    },
    {
      "id": 134,
      "question": "Как избежать перегрузки логирования в многопоточном приложении?",
      "options": {
        "A": "Ограничивать объем записываемых логов",
        "B": "Использовать только консольное логирование",
        "C": "Записывать все логи в оперативную память",
        "D": "Снижать уровень логирования до TRACE",
        "E": "Увеличить размер файла логов"
      },
      "correct": "A"
    },
    {
      "id": 135,
      "question": "Какой библиотекой логирования Spring пользуется по умолчанию?",
      "options": {
        "A": "log4j",
        "B": "SLF4J",
        "C": "java.util.logging",
        "D": "Logback",
        "E": "Spring Logging"
      },
      "correct": "D"
    },
    {
      "id": 136,
      "question": "Как настроить уровень логирования в Spring Boot?",
      "options": {
        "A": "Через аннотации @LogConfig",
        "B": "В файле application.properties или application.yml",
        "C": "Через файл logback-default.xml",
        "D": "Только программно через Java-код",
        "E": "Через конфигурацию в pom.xml"
      },
      "correct": "B"
    },
    {
      "id": 137,
      "question": "Какой файл конфигурации используется Logback в Spring Boot?",
      "options": {
        "A": "logback-spring.xml",
        "B": "logback.xml",
        "C": "spring-log.xml",
        "D": "application-logback.yml",
        "E": "logback-config.xml"
      },
      "correct": "A"
    },
    {
      "id": 138,
      "question": "Какой аннотацией можно автоматически подключить логгер в классе Spring?",
      "options": {
        "A": "@Slf4j",
        "B": "@EnableLogging",
        "C": "@Log4j",
        "D": "@Logger",
        "E": "@Log"
      },
      "correct": "A"
    },
    {
      "id": 139,
      "question": "Что делает параметр logging.level в Spring Boot?",
      "options": {
        "A": "Устанавливает уровень логирования для конкретного пакета или класса",
        "B": "Включает только консольное логирование",
        "C": "Указывает путь для сохранения логов",
        "D": "Определяет формат вывода логов",
        "E": "Управляет асинхронным логированием"
      },
      "correct": "A"
    },
    {
      "id": 140,
      "question": "Как включить асинхронное логирование в Spring Boot?",
      "options": {
        "A": "Добавить аннотацию @AsyncLogging",
        "B": "Настроить AsyncAppender в logback-spring.xml",
        "C": "Использовать стандартные настройки Spring Boot",
        "D": "Установить уровень логирования на DEBUG",
        "E": "Включить асинхронный режим в application.properties"
      },
      "correct": "B"
    },
    {
      "id": 141,
      "question": "Что такое уровень логирования?",
      "options": {
        "A": "Метод записи логов в базу данных",
        "B": "Уровень детализации информации, записываемой в логи",
        "C": "Инструмент для работы с потоками",
        "D": "Настройка частоты записи логов",
        "E": "Способ форматирования логов"
      },
      "correct": "B"
    },
    {
      "id": 142,
      "question": "Какой уровень логирования используется для отладки приложения?",
      "options": {
        "A": "ERROR",
        "B": "WARN",
        "C": "DEBUG",
        "D": "FATAL",
        "E": "INFO"
      },
      "correct": "C"
    },
    {
      "id": 143,
      "question": "Какой уровень логирования следует использовать для записи информации об ошибках?",
      "options": {
        "A": "ERROR",
        "B": "INFO",
        "C": "DEBUG",
        "D": "TRACE",
        "E": "WARN"
      },
      "correct": "A"
    },
    {
      "id": 144,
      "question": "Что такое Appender в log4j?",
      "options": {
        "A": "Компонент для записи логов в конкретное место (файл, консоль и т. д.)",
        "B": "Метод фильтрации логов",
        "C": "Класс для форматирования логов",
        "D": "Уровень логирования",
        "E": "Инструмент для анализа логов"
      },
      "correct": "A"
    },
    {
      "id": 145,
      "question": "Какой Appender записывает логи в файл?",
      "options": {
        "A": "FileAppender",
        "B": "ConsoleAppender",
        "C": "RollingFileAppender",
        "D": "DatabaseAppender",
        "E": "MemoryAppender"
      },
      "correct": "A"
    },
    {
      "id": 146,
      "question": "Что делает RollingFileAppender?",
      "options": {
        "A": "Удаляет старые логи после их записи",
        "B": "Создает новые файлы логов при достижении заданного размера",
        "C": "Фильтрует логи по ключевым словам",
        "D": "Логирует только последние события",
        "E": "Архивирует логи автоматически"
      },
      "correct": "B"
    },
    {
      "id": 147,
      "question": "Как настроить вывод логов в log4j на консоль?",
      "options": {
        "A": "Использовать ConsoleAppender",
        "B": "Использовать FileAppender",
        "C": "Настроить уровень TRACE",
        "D": "Подключить SLF4J",
        "E": "Использовать PatternLayout"
      },
      "correct": "A"
    },
    {
      "id": 148,
      "question": "Какой параметр отвечает за форматирование логов в log4j?",
      "options": {
        "A": "Layout",
        "B": "Filter",
        "C": "Appender",
        "D": "Logger",
        "E": "Formatter"
      },
      "correct": "A"
    },
    {
      "id": 149,
      "question": "Какой Layout в log4j позволяет настроить простой формат логов?",
      "options": {
        "A": "PatternLayout",
        "B": "XMLLayout",
        "C": "HTMLLayout",
        "D": "JsonLayout",
        "E": "SimpleLayout"
      },
      "correct": "A"
    },
    {
      "id": 150,
      "question": "Что такое MDC в логировании?",
      "options": {
        "A": "Механизм для передачи контекстной информации в логи",
        "B": "Компонент для хранения логов в памяти",
        "C": "Уровень логирования для многопоточных приложений",
        "D": "Функция для форматирования логов",
        "E": "Инструмент для анализа логов"
      },
      "correct": "A"
    },
    {
      "id": 151,
      "question": "Чем отличается NDC от MDC?",
      "options": {
        "A": "NDC используется для настройки уровней логирования",
        "B": "MDC хранит только данные потока, а NDC — общие данные",
        "C": "MDC хранит данные в формате ключ-значение, NDC — в формате стека",
        "D": "NDC применяется только в Spring",
        "E": "NDC используется для асинхронного логирования"
      },
      "correct": "C"
    },
    {
      "id": 152,
      "question": "Что произойдет, если не задать реализацию Appender?",
      "options": {
        "A": "Логи не будут записываться",
        "B": "Логи будут записываться в консоль по умолчанию",
        "C": "Логи автоматически отправятся в файл",
        "D": "Логирование будет происходить в памяти",
        "E": "Логирование будет отключено"
      },
      "correct": "A"
    },
    {
      "id": 153,
      "question": "Какую библиотеку лучше использовать для асинхронного логирования?",
      "options": {
        "A": "java.util.logging",
        "B": "SLF4J",
        "C": "log4j2",
        "D": "Logback",
        "E": "AsyncLogger"
      },
      "correct": "C"
    },
    {
      "id": 154,
      "question": "Как включить отладочное логирование в Spring Boot?",
      "options": {
        "A": "Добавить аннотацию @EnableDebug",
        "B": "Включить флаг debug=true в application.yml",
        "C": "Установить уровень логирования на DEBUG в application.properties",
        "D": "Настроить logback-spring.xml",
        "E": "Использовать асинхронное логирование"
      },
      "correct": "C"
    },
    {
      "id": 155,
      "question": "Как настроить ротацию логов в Logback?",
      "options": {
        "A": "Использовать RollingFileAppender",
        "B": "Установить уровень логирования TRACE",
        "C": "Включить AsyncAppender",
        "D": "Настроить ConsoleAppender",
        "E": "Использовать FileAppender"
      },
      "correct": "A"
    },
    {
      "id": 156,
      "question": "Какой интерфейс SLF4J используется для работы с логами?",
      "options": {
        "A": "org.slf4j.Logger",
        "B": "org.slf4j.LoggingManager",
        "C": "org.slf4j.Appender",
        "D": "org.slf4j.PatternLayout",
        "E": "org.slf4j.Log"
      },
      "correct": "A"
    },
    {
      "id": 157,
      "question": "Как создать экземпляр логгера в SLF4J?",
      "options": {
        "A": "Logger logger = new Logger();",
        "B": "Logger logger = SLF4J.getLogger();",
        "C": "Logger logger = LoggerFactory.getLogger(MyClass.class);",
        "D": "Logger logger = new LoggerFactory();",
        "E": "Logger logger = Logger.create();"
      },
      "correct": "C"
    },
    {
      "id": 158,
      "question": "Какой параметр отвечает за указание уровня логирования в SLF4J?",
      "options": {
        "A": "Appender.level",
        "B": "logging.level",
        "C": "Logger.level",
        "D": "slf4j.level",
        "E": "log.level"
      },
      "correct": "B"
    },
    {
      "id": 159,
      "question": "Как настроить логирование в асинхронном режиме в log4j2?",
      "options": {
        "A": "Использовать AsyncAppender",
        "B": "Настроить FileAppender",
        "C": "Включить TRACE уровень",
        "D": "Использовать PatternLayout",
        "E": "Включить асинхронный режим в конфигурации"
      },
      "correct": "A"
    },
    {
      "id": 161,
      "question": "Для чего используется аннотация @Test в JUnit?",
      "options": {
        "A": "Для подключения тестовой базы данных",
        "B": "Для создания основного метода",
        "C": "Для определения метода как тестового",
        "D": "Для указания на статический метод",
        "E": "Для генерации отчета о тестировании"
      },
      "correct": "C"
    },
    {
      "id": 162,
      "question": "Какая аннотация используется для выполнения кода перед каждым тестом?",
      "options": {
        "A": "@After",
        "B": "@Before",
        "C": "@Setup",
        "D": "@Initialize",
        "E": "@PreRun"
      },
      "correct": "B"
    },
    {
      "id": 163,
      "question": "Какой метод следует использовать для проверки равенства двух значений в JUnit?",
      "options": {
        "A": "assertNotNull()",
        "B": "assertFalse()",
        "C": "assertEquals()",
        "D": "assertTrue()",
        "E": "assertSame()"
      },
      "correct": "C"
    },
    {
      "id": 164,
      "question": "Что происходит, если тест в JUnit завершается с исключением?",
      "options": {
        "A": "Тест считается успешным",
        "B": "Тест считается проваленным",
        "C": "Тест пропускается",
        "D": "Исключение игнорируется",
        "E": "Выполняется метод @After"
      },
      "correct": "B"
    },
    {
      "id": 165,
      "question": "Какой из перечисленных методов не входит в стандартные функции JUnit?",
      "options": {
        "A": "assertArrayEquals()",
        "B": "assertNotNull()",
        "C": "validateInput()",
        "D": "assertSame()",
        "E": "assertThrows()"
      },
      "correct": "C"
    },
    {
      "id": 166,
      "question": "Что из перечисленного используется для проверки выброса исключения?",
      "options": {
        "A": "assertEquals()",
        "B": "assertTrue()",
        "C": "assertNotNull()",
        "D": "assertThrows()",
        "E": "assertFalse()"
      },
      "correct": "D"
    },
    {
      "id": 167,
      "question": "Как можно запускать тесты с разными наборами данных в JUnit?",
      "options": {
        "A": "С использованием assertSame()",
        "B": "Через метод @Before",
        "C": "С использованием аннотации @ParameterizedTest",
        "D": "Через аннотацию @Test",
        "E": "С использованием assertArrayEquals()"
      },
      "correct": "C"
    },
    {
      "id": 168,
      "question": "Что используется для группировки тестов в JUnit?",
      "options": {
        "A": "@TestSuite",
        "B": "@GroupTest",
        "C": "@IntegrationTest",
        "D": "@Suite",
        "E": "@Cluster"
      },
      "correct": "D"
    },
    {
      "id": 169,
      "question": "Какая аннотация в JUnit позволяет временно отключить тест?",
      "options": {
        "A": "@Disabled",
        "B": "@IgnoreTest",
        "C": "@Skip",
        "D": "@Exclude",
        "E": "@Postpone"
      },
      "correct": "A"
    },
    {
      "id": 170,
      "question": "Какой элемент используется для проверки выполнения кода в многопоточном режиме?",
      "options": {
        "A": "assertNull()",
        "B": "assertArrayEquals()",
        "C": "assertTimeout()",
        "D": "assertInstanceOf()",
        "E": "assertThrows()"
      },
      "correct": "C"
    },
    {
      "id": 171,
      "question": "Какой метод MockMVC используется для выполнения GET-запросов?",
      "options": {
        "A": "post()",
        "B": "put()",
        "C": "get()",
        "D": "delete()",
        "E": "patch()"
      },
      "correct": "C"
    },
    {
      "id": 172,
      "question": "Что из перечисленного возвращает метод andReturn() в MockMVC?",
      "options": {
        "A": "HttpResponse",
        "B": "RequestHandler",
        "C": "MvcResult",
        "D": "HttpServletRequest",
        "E": "JsonResult"
      },
      "correct": "C"
    },
    {
      "id": 173,
      "question": "Для чего используется метод perform() в MockMVC?",
      "options": {
        "A": "Для проверки состояния базы данных",
        "B": "Для анализа логов",
        "C": "Для выполнения HTTP-запроса",
        "D": "Для настройки контроллера",
        "E": "Для создания REST-эндпоинта"
      },
      "correct": "C"
    },
    {
      "id": 174,
      "question": "Какой метод в MockMVC используется для проверки HTTP-статуса?",
      "options": {
        "A": "andView()",
        "B": "andForward()",
        "C": "andExpect()",
        "D": "andProcess()",
        "E": "andReturn()"
      },
      "correct": "C"
    },
    {
      "id": 175,
      "question": "Что из перечисленного используется для проверки тела ответа в MockMVC?",
      "options": {
        "A": "checkBody()",
        "B": "validateResponse()",
        "C": "content()",
        "D": "assertBody()",
        "E": "responseBody()"
      },
      "correct": "C"
    },
    {
      "id": 176,
      "question": "Какой метод используется для проверки наличия определенного JSON-поля?",
      "options": {
        "A": "checkField()",
        "B": "validateJson()",
        "C": "andJsonField()",
        "D": "jsonPath()",
        "E": "contentField()"
      },
      "correct": "D"
    },
    {
      "id": 177,
      "question": "Что из перечисленного лучше всего описывает интеграционное тестирование?",
      "options": {
        "A": "Тестирование одной функции",
        "B": "Анализ отказоустойчивости",
        "C": "Проверка взаимодействия между компонентами",
        "D": "Тестирование производительности",
        "E": "Проверка корректности ввода"
      },
      "correct": "C"
    },
    {
      "id": 178,
      "question": "Какой из статусов HTTP чаще всего используется для успешных POST-запросов?",
      "options": {
        "A": "400",
        "B": "201",
        "C": "500",
        "D": "202",
        "E": "204"
      },
      "correct": "B"
    },
    {
      "id": 179,
      "question": "Что позволяет делать метод param() в MockMVC?",
      "options": {
        "A": "Изменять URL запроса",
        "B": "Проверять заголовки ответа",
        "C": "Передавать параметры в запрос",
        "D": "Изменять метод запроса",
        "E": "Проверять тело ответа"
      },
      "correct": "C"
    },
    {
      "id": 181,
      "question": "Что из перечисленного не относится к best practices интеграционного тестирования?",
      "options": {
        "A": "Использование изолированных тестовых данных",
        "B": "Создание тестов, проверяющих взаимодействие компонентов",
        "C": "Тестирование одной функции в изоляции",
        "D": "Проверка совместимости модулей",
        "E": "Использование моков и заглушек"
      },
      "correct": "C"
    },
    {
      "id": 182,
      "question": "Какой из подходов помогает ускорить интеграционное тестирование?",
      "options": {
        "A": "Использование большого объема данных",
        "B": "Игнорирование повторяющихся тестов",
        "C": "Параллельное выполнение тестов",
        "D": "Упрощение тестовых сценариев",
        "E": "Увеличение числа модулей"
      },
      "correct": "C"
    },
    {
      "id": 183,
      "question": "Какой из типов тестов подходит для проверки взаимодействия с внешним API?",
      "options": {
        "A": "Unit-тесты",
        "B": "Smoke-тесты",
        "C": "Интеграционные тесты",
        "D": "A/B-тесты",
        "E": "Нагрузочные тесты"
      },
      "correct": "C"
    },
    {
      "id": 184,
      "question": "Какую роль выполняют заглушки в интеграционном тестировании?",
      "options": {
        "A": "Ускоряют работу приложения",
        "B": "Эмулируют поведение внешних компонентов",
        "C": "Повышают производительность тестов",
        "D": "Проверяют надежность API",
        "E": "Оптимизируют производительность"
      },
      "correct": "B"
    },
    {
      "id": 185,
      "question": "Какой статус лучше всего использовать для успешного ответа на GET-запрос?",
      "options": {
        "A": "400",
        "B": "201",
        "C": "200",
        "D": "500",
        "E": "202"
      },
      "correct": "C"
    },
    {
      "id": 186,
      "question": "Что из перечисленного лучше всего описывает юнит-тестирование?",
      "options": {
        "A": "Тестирование взаимодействия компонентов",
        "B": "Тестирование отдельных методов или функций",
        "C": "Проверка производительности системы",
        "D": "Тестирование отказоустойчивости",
        "E": "Проверка пользовательского интерфейса"
      },
      "correct": "B"
    },
    {
      "id": 187,
      "question": "Какую аннотацию в JUnit используют для тестов, которые ожидают определенного исключения?",
      "options": {
        "A": "@TestIgnore",
        "B": "@ExpectedException",
        "C": "@AssertException",
        "D": "@Test(expected = Exception.class)",
        "E": "@ErrorExpected"
      },
      "correct": "D"
    },
    {
      "id": 188,
      "question": "Какой метод MockMVC используется для выполнения POST-запросов?",
      "options": {
        "A": "get()",
        "B": "post()",
        "C": "put()",
        "D": "delete()",
        "E": "patch()"
      },
      "correct": "B"
    },
    {
      "id": 189,
      "question": "Какой из типов тестов позволяет убедиться, что приложение работает корректно после внесения изменений?",
      "options": {
        "A": "Нагрузочные тесты",
        "B": "Интеграционные тесты",
        "C": "Модульные тесты",
        "D": "Регрессионные тесты",
        "E": "Приемочные тесты"
      },
      "correct": "D"
    },
    {
      "id": 190,
      "question": "Какой HTTP-метод чаще всего используется для обновления существующего ресурса?",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "POST",
        "D": "DELETE",
        "E": "PATCH"
      },
      "correct": "B"
    },
    {
      "id": 191,
      "question": "Какой метод MockMVC используется для проверки значения заголовка ответа?",
      "options": {
        "A": "andBody()",
        "B": "andReturn()",
        "C": "andExpectContent()",
        "D": "andExpect(header())",
        "E": "andValidate()"
      },
      "correct": "D"
    },
    {
      "id": 192,
      "question": "Что из перечисленного не является преимуществом юнит-тестирования?",
      "options": {
        "A": "Быстрая проверка функциональности",
        "B": "Повышение качества кода",
        "C": "Обнаружение ошибок на ранних стадиях",
        "D": "Тестирование взаимодействия компонентов",
        "E": "Упрощение рефакторинга"
      },
      "correct": "D"
    },
    {
      "id": 193,
      "question": "Какой из статусов HTTP чаще всего используется для неавторизованных запросов?",
      "options": {
        "A": "404",
        "B": "400",
        "C": "401",
        "D": "200",
        "E": "500"
      },
      "correct": "C"
    },
    {
      "id": 194,
      "question": "Что означает аннотация @BeforeEach в JUnit?",
      "options": {
        "A": "Выполняет код после каждого теста",
        "B": "Выполняет код перед каждым тестом",
        "C": "Выполняет код перед всеми тестами",
        "D": "Выполняет код один раз перед запуском тестов",
        "E": "Выполняет код после завершения всех тестов"
      },
      "correct": "B"
    },
    {
      "id": 195,
      "question": "Какой метод используется для проверки тела ответа в формате JSON в MockMVC?",
      "options": {
        "A": "jsonBody()",
        "B": "checkContent()",
        "C": "content().json()",
        "D": "validateJson()",
        "E": "response().body()"
      },
      "correct": "C"
    },
    {
      "id": 196,
      "question": "Какой метод используется для выполнения PATCH-запросов в MockMVC?",
      "options": {
        "A": "get()",
        "B": "post()",
        "C": "put()",
        "D": "delete()",
        "E": "patch()"
      },
      "correct": "E"
    },
    {
      "id": 197,
      "question": "Что означает аннотация @AfterAll в JUnit?",
      "options": {
        "A": "Выполняет код перед каждым тестом",
        "B": "Выполняет код после каждого теста",
        "C": "Выполняет код перед запуском всех тестов",
        "D": "Выполняет код после завершения всех тестов",
        "E": "Выполняет код только для одного теста"
      },
      "correct": "D"
    },
    {
      "id": 198,
      "question": "Какая из следующих проверок подходит для асинхронного тестирования в JUnit?",
      "options": {
        "A": "assertNull()",
        "B": "assertTimeout()",
        "C": "assertSame()",
        "D": "assertArrayEquals()",
        "E": "assertNotNull()"
      },
      "correct": "B"
    },
    {
      "id": 199,
      "question": "Какой метод MockMVC используется для добавления параметров в запрос?",
      "options": {
        "A": "header()",
        "B": "param()",
        "C": "body()",
        "D": "query()",
        "E": "args()"
      },
      "correct": "B"
    },
    {
      "id": 200,
      "question": "Что из перечисленного лучше всего описывает цель интеграционного тестирования?",
      "options": {
        "A": "Проверка производительности одного компонента",
        "B": "Проверка пользовательского интерфейса",
        "C": "Обнаружение багов в коде",
        "D": "Проверка взаимодействия между модулями",
        "E": "Улучшение структуры кода"
      },
      "correct": "D"
    },
    {
      "id": 201,
      "question": "Какой компонент Spring используется для управления зависимостями?",
      "options": {
        "A": "Spring MVC",
        "B": "Spring Context",
        "C": "Spring ORM",
        "D": "Spring Boot",
        "E": "Spring Core"
      },
      "correct": "B"
    },
    {
      "id": 202,
      "question": "Как называется файл конфигурации Spring, используемый по умолчанию?",
      "options": {
        "A": "spring.xml",
        "B": "application.properties",
        "C": "app.config",
        "D": "spring-config.xml",
        "E": "config.properties"
      },
      "correct": "B"
    },
    {
      "id": 203,
      "question": "Что означает аннотация @Autowired?",
      "options": {
        "A": "Автоматическая инъекция зависимости",
        "B": "Объявление нового сервиса",
        "C": "Определение URL",
        "D": "Управление транзакциями",
        "E": "Настройка конфигурации"
      },
      "correct": "A"
    },
    {
      "id": 204,
      "question": "Что делает аннотация @RestController?",
      "options": {
        "A": "Связывает сервисы",
        "B": "Определяет класс как контроллер REST API",
        "C": "Создаёт транзакцию",
        "D": "Настраивает свойства",
        "E": "Управляет зависимостями"
      },
      "correct": "B"
    },
    {
      "id": 205,
      "question": "Какая аннотация используется для указания метода как конечной точки?",
      "options": {
        "A": "@Controller",
        "B": "@Autowired",
        "C": "@RequestMapping",
        "D": "@Service",
        "E": "@Endpoint"
      },
      "correct": "C"
    },
    {
      "id": 206,
      "question": "Какой модуль Spring используется для работы с базами данных?",
      "options": {
        "A": "Spring MVC",
        "B": "Spring Context",
        "C": "Spring Data",
        "D": "Spring Security",
        "E": "Spring JDBC"
      },
      "correct": "C"
    },
    {
      "id": 207,
      "question": "Что означает аннотация @Transactional?",
      "options": {
        "A": "Открытие транзакции для метода",
        "B": "Связывание данных",
        "C": "Объявление контроллера",
        "D": "Оптимизация запроса",
        "E": "Управление контекстом"
      },
      "correct": "A"
    },
    {
      "id": 208,
      "question": "Какой класс Spring используется для запуска приложения?",
      "options": {
        "A": "SpringApplication",
        "B": "SpringContext",
        "C": "SpringBootLoader",
        "D": "SpringStart",
        "E": "SpringRunner"
      },
      "correct": "A"
    },
    {
      "id": 209,
      "question": "Что делает аннотация @Component?",
      "options": {
        "A": "Определяет компонент для управления контейнером Spring",
        "B": "Объявляет сервис",
        "C": "Настраивает URL",
        "D": "Запускает приложение",
        "E": "Управляет транзакциями"
      },
      "correct": "A"
    },
    {
      "id": 210,
      "question": "Какой из следующих Docker-команд запускает контейнер?",
      "options": {
        "A": "docker build",
        "B": "docker run",
        "C": "docker start",
        "D": "docker exec",
        "E": "docker launch"
      },
      "correct": "B"
    },
    {
      "id": 211,
      "question": "Какой файл используется для описания образа Docker?",
      "options": {
        "A": "DockerProps",
        "B": "Dockerfile",
        "C": "Docker.config",
        "D": "DockerManifest",
        "E": "DockerImage"
      },
      "correct": "B"
    },
    {
      "id": 212,
      "question": "Какой командой создаётся образ из Dockerfile?",
      "options": {
        "A": "docker build",
        "B": "docker run",
        "C": "docker create",
        "D": "docker init",
        "E": "docker compose"
      },
      "correct": "A"
    },
    {
      "id": 213,
      "question": "Какая команда показывает работающие контейнеры?",
      "options": {
        "A": "docker ls",
        "B": "docker ps",
        "C": "docker show",
        "D": "docker status",
        "E": "docker list"
      },
      "correct": "B"
    },
    {
      "id": 214,
      "question": "Как остановить контейнер Docker?",
      "options": {
        "A": "docker remove",
        "B": "docker stop",
        "C": "docker halt",
        "D": "docker kill",
        "E": "docker pause"
      },
      "correct": "B"
    },
    {
      "id": 215,
      "question": "Какой ключ используется для указания порта в docker run?",
      "options": {
        "A": "-p",
        "B": "-v",
        "C": "-port",
        "D": "-e",
        "E": "-expose"
      },
      "correct": "A"
    },
    {
      "id": 216,
      "question": "Как удалить контейнер Docker?",
      "options": {
        "A": "docker stop",
        "B": "docker rm",
        "C": "docker delete",
        "D": "docker clean",
        "E": "docker remove"
      },
      "correct": "B"
    },
    {
      "id": 217,
      "question": "Как посмотреть логи контейнера?",
      "options": {
        "A": "docker show logs",
        "B": "docker status logs",
        "C": "docker logs",
        "D": "docker info logs",
        "E": "docker view logs"
      },
      "correct": "C"
    },
    {
      "id": 218,
      "question": "Какой командой создаётся сеть Docker?",
      "options": {
        "A": "docker network create",
        "B": "docker net init",
        "C": "docker create network",
        "D": "docker setup network",
        "E": "docker network init"
      },
      "correct": "A"
    },
    {
      "id": 219,
      "question": "Как подключить контейнер к сети?",
      "options": {
        "A": "docker link network",
        "B": "docker network connect",
        "C": "docker attach network",
        "D": "docker bridge network",
        "E": "docker join network"
      },
      "correct": "B"
    },
    {
      "id": 220,
      "question": "Какой инструмент используется для управления многоконтейнерными приложениями?",
      "options": {
        "A": "DockerFile",
        "B": "DockerNet",
        "C": "Docker Compose",
        "D": "Docker Manager",
        "E": "Docker Swarm"
      },
      "correct": "C"
    },
    {
      "id": 221,
      "question": "Какая команда используется для создания нового репозитория Git?",
      "options": {
        "A": "git create",
        "B": "git init",
        "C": "git start",
        "D": "git new",
        "E": "git repo"
      },
      "correct": "B"
    },
    {
      "id": 222,
      "question": "Какая команда отображает текущий статус репозитория?",
      "options": {
        "A": "git log",
        "B": "git commit",
        "C": "git status",
        "D": "git branch",
        "E": "git info"
      },
      "correct": "C"
    },
    {
      "id": 223,
      "question": "Какой командой можно зафиксировать изменения в локальном репозитории?",
      "options": {
        "A": "git add",
        "B": "git commit",
        "C": "git push",
        "D": "git clone",
        "E": "git save"
      },
      "correct": "B"
    },
    {
      "id": 224,
      "question": "Какая команда используется для добавления файлов в индекс (staging area)?",
      "options": {
        "A": "git commit",
        "B": "git add",
        "C": "git merge",
        "D": "git stage",
        "E": "git track"
      },
      "correct": "B"
    },
    {
      "id": 225,
      "question": "Какой командой можно отправить изменения в удалённый репозиторий?",
      "options": {
        "A": "git fetch",
        "B": "git pull",
        "C": "git push",
        "D": "git sync",
        "E": "git upload"
      },
      "correct": "C"
    },
    {
      "id": 226,
      "question": "Какая команда используется для слияния веток?",
      "options": {
        "A": "git branch",
        "B": "git merge",
        "C": "git checkout",
        "D": "git rebase",
        "E": "git combine"
      },
      "correct": "B"
    },
    {
      "id": 227,
      "question": "Какой командой можно создать новую ветку?",
      "options": {
        "A": "git switch",
        "B": "git add-branch",
        "C": "git branch",
        "D": "git init",
        "E": "git create-branch"
      },
      "correct": "C"
    },
    {
      "id": 228,
      "question": "Как узнать историю коммитов в репозитории?",
      "options": {
        "A": "git status",
        "B": "git branch",
        "C": "git log",
        "D": "git info",
        "E": "git history"
      },
      "correct": "C"
    },
    {
      "id": 229,
      "question": "Какая команда используется для получения изменений из удалённого репозитория?",
      "options": {
        "A": "git pull",
        "B": "git push",
        "C": "git fetch",
        "D": "git clone",
        "E": "git sync"
      },
      "correct": "A"
    },
    {
      "id": 230,
      "question": "Какая команда удаляет файл из индекса и рабочей директории?",
      "options": {
        "A": "git rm",
        "B": "git delete",
        "C": "git remove",
        "D": "git clean",
        "E": "git discard"
      },
      "correct": "A"
    },
    {
      "id": 231,
      "question": "Что делает команда git clone?",
      "options": {
        "A": "Удаляет репозиторий",
        "B": "Сравнивает ветки",
        "C": "Копирует удалённый репозиторий",
        "D": "Объединяет ветки",
        "E": "Создаёт новый репозиторий"
      },
      "correct": "C"
    },
    {
      "id": 232,
      "question": "Какая команда используется для восстановления удалённых файлов?",
      "options": {
        "A": "git restore",
        "B": "git reset",
        "C": "git revert",
        "D": "git recover",
        "E": "git undo"
      },
      "correct": "A"
    },
    {
      "id": 233,
      "question": "Как удалить последнюю фиксацию, сохранив изменения в файлах?",
      "options": {
        "A": "git delete",
        "B": "git pull",
        "C": "git reset --soft HEAD~1",
        "D": "git revert",
        "E": "git undo"
      },
      "correct": "C"
    },
    {
      "id": 234,
      "question": "Как узнать URL удалённого репозитория?",
      "options": {
        "A": "git remote -v",
        "B": "git status",
        "C": "git fetch",
        "D": "git log",
        "E": "git remote show"
      },
      "correct": "A"
    },
    {
      "id": 235,
      "question": "Какая команда используется для отката к определённому коммиту?",
      "options": {
        "A": "git checkout",
        "B": "git merge",
        "C": "git reset",
        "D": "git revert",
        "E": "git rollback"
      },
      "correct": "A"
    },
    {
      "id": 236,
      "question": "Какая команда показывает, какие строки в файле были изменены в коммитах?",
      "options": {
        "A": "git log",
        "B": "git blame",
        "C": "git annotate",
        "D": "git history",
        "E": "git diff"
      },
      "correct": "B"
    },
    {
      "id": 237,
      "question": "Какой файл используется для игнорирования файлов в Git?",
      "options": {
        "A": ".gitstatus",
        "B": ".gitrepo",
        "C": ".gitignore",
        "D": ".gittrack",
        "E": ".gitconfig"
      },
      "correct": "C"
    },
    {
      "id": 238,
      "question": "Что делает команда git stash?",
      "options": {
        "A": "Удаляет файлы",
        "B": "Коммитит изменения",
        "C": "Сохраняет временные изменения",
        "D": "Создаёт ветку",
        "E": "Отменяет последний коммит"
      },
      "correct": "C"
    },
    {
      "id": 239,
      "question": "Какой командой можно посмотреть список сохранённых stash?",
      "options": {
        "A": "git log",
        "B": "git stash list",
        "C": "git history",
        "D": "git save",
        "E": "git stash show"
      },
      "correct": "B"
    },
    {
      "id": 240,
      "question": "Как объединить два репозитория?",
      "options": {
        "A": "git clone",
        "B": "git pull upstream",
        "C": "git rebase",
        "D": "git merge"
      },
      "correct": "B"
    }
  ]
}